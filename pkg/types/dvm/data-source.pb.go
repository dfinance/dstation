// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dfinance/dvm/data-source.proto

package dvm

import (
	context "context"
	fmt "fmt"
	grpc1 "github.com/gogo/protobuf/grpc"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ErrorCode int32

const (
	ErrorCode_NONE        ErrorCode = 0
	ErrorCode_BAD_REQUEST ErrorCode = 1
	ErrorCode_NO_DATA     ErrorCode = 2
)

var ErrorCode_name = map[int32]string{
	0: "NONE",
	1: "BAD_REQUEST",
	2: "NO_DATA",
}

var ErrorCode_value = map[string]int32{
	"NONE":        0,
	"BAD_REQUEST": 1,
	"NO_DATA":     2,
}

func (x ErrorCode) String() string {
	return proto.EnumName(ErrorCode_name, int32(x))
}

func (ErrorCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1f281398717634ce, []int{0}
}

type DSAccessPath struct {
	Address []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Path    []byte `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *DSAccessPath) Reset()         { *m = DSAccessPath{} }
func (m *DSAccessPath) String() string { return proto.CompactTextString(m) }
func (*DSAccessPath) ProtoMessage()    {}
func (*DSAccessPath) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f281398717634ce, []int{0}
}
func (m *DSAccessPath) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DSAccessPath) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DSAccessPath.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DSAccessPath) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DSAccessPath.Merge(m, src)
}
func (m *DSAccessPath) XXX_Size() int {
	return m.Size()
}
func (m *DSAccessPath) XXX_DiscardUnknown() {
	xxx_messageInfo_DSAccessPath.DiscardUnknown(m)
}

var xxx_messageInfo_DSAccessPath proto.InternalMessageInfo

func (m *DSAccessPath) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *DSAccessPath) GetPath() []byte {
	if m != nil {
		return m.Path
	}
	return nil
}

type DSRawResponse struct {
	Blob         []byte    `protobuf:"bytes,1,opt,name=blob,proto3" json:"blob,omitempty"`
	ErrorCode    ErrorCode `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3,enum=dfinance.dvm.ErrorCode" json:"error_code,omitempty"`
	ErrorMessage string    `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *DSRawResponse) Reset()         { *m = DSRawResponse{} }
func (m *DSRawResponse) String() string { return proto.CompactTextString(m) }
func (*DSRawResponse) ProtoMessage()    {}
func (*DSRawResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f281398717634ce, []int{1}
}
func (m *DSRawResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DSRawResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DSRawResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DSRawResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DSRawResponse.Merge(m, src)
}
func (m *DSRawResponse) XXX_Size() int {
	return m.Size()
}
func (m *DSRawResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DSRawResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DSRawResponse proto.InternalMessageInfo

func (m *DSRawResponse) GetBlob() []byte {
	if m != nil {
		return m.Blob
	}
	return nil
}

func (m *DSRawResponse) GetErrorCode() ErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return ErrorCode_NONE
}

func (m *DSRawResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

type DSAccessPaths struct {
	Paths []*DSAccessPath `protobuf:"bytes,1,rep,name=paths,proto3" json:"paths,omitempty"`
}

func (m *DSAccessPaths) Reset()         { *m = DSAccessPaths{} }
func (m *DSAccessPaths) String() string { return proto.CompactTextString(m) }
func (*DSAccessPaths) ProtoMessage()    {}
func (*DSAccessPaths) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f281398717634ce, []int{2}
}
func (m *DSAccessPaths) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DSAccessPaths) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DSAccessPaths.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DSAccessPaths) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DSAccessPaths.Merge(m, src)
}
func (m *DSAccessPaths) XXX_Size() int {
	return m.Size()
}
func (m *DSAccessPaths) XXX_DiscardUnknown() {
	xxx_messageInfo_DSAccessPaths.DiscardUnknown(m)
}

var xxx_messageInfo_DSAccessPaths proto.InternalMessageInfo

func (m *DSAccessPaths) GetPaths() []*DSAccessPath {
	if m != nil {
		return m.Paths
	}
	return nil
}

type DSRawResponses struct {
	Blobs [][]byte `protobuf:"bytes,1,rep,name=blobs,proto3" json:"blobs,omitempty"`
}

func (m *DSRawResponses) Reset()         { *m = DSRawResponses{} }
func (m *DSRawResponses) String() string { return proto.CompactTextString(m) }
func (*DSRawResponses) ProtoMessage()    {}
func (*DSRawResponses) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f281398717634ce, []int{3}
}
func (m *DSRawResponses) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DSRawResponses) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DSRawResponses.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DSRawResponses) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DSRawResponses.Merge(m, src)
}
func (m *DSRawResponses) XXX_Size() int {
	return m.Size()
}
func (m *DSRawResponses) XXX_DiscardUnknown() {
	xxx_messageInfo_DSRawResponses.DiscardUnknown(m)
}

var xxx_messageInfo_DSRawResponses proto.InternalMessageInfo

func (m *DSRawResponses) GetBlobs() [][]byte {
	if m != nil {
		return m.Blobs
	}
	return nil
}

type OraclePriceRequest struct {
	Currency_1 string `protobuf:"bytes,1,opt,name=currency_1,json=currency1,proto3" json:"currency_1,omitempty"`
	Currency_2 string `protobuf:"bytes,2,opt,name=currency_2,json=currency2,proto3" json:"currency_2,omitempty"`
}

func (m *OraclePriceRequest) Reset()         { *m = OraclePriceRequest{} }
func (m *OraclePriceRequest) String() string { return proto.CompactTextString(m) }
func (*OraclePriceRequest) ProtoMessage()    {}
func (*OraclePriceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f281398717634ce, []int{4}
}
func (m *OraclePriceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OraclePriceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OraclePriceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OraclePriceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OraclePriceRequest.Merge(m, src)
}
func (m *OraclePriceRequest) XXX_Size() int {
	return m.Size()
}
func (m *OraclePriceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OraclePriceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OraclePriceRequest proto.InternalMessageInfo

func (m *OraclePriceRequest) GetCurrency_1() string {
	if m != nil {
		return m.Currency_1
	}
	return ""
}

func (m *OraclePriceRequest) GetCurrency_2() string {
	if m != nil {
		return m.Currency_2
	}
	return ""
}

type OraclePriceResponse struct {
	Price        *U128     `protobuf:"bytes,1,opt,name=price,proto3" json:"price,omitempty"`
	ErrorCode    ErrorCode `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3,enum=dfinance.dvm.ErrorCode" json:"error_code,omitempty"`
	ErrorMessage string    `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *OraclePriceResponse) Reset()         { *m = OraclePriceResponse{} }
func (m *OraclePriceResponse) String() string { return proto.CompactTextString(m) }
func (*OraclePriceResponse) ProtoMessage()    {}
func (*OraclePriceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f281398717634ce, []int{5}
}
func (m *OraclePriceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OraclePriceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OraclePriceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OraclePriceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OraclePriceResponse.Merge(m, src)
}
func (m *OraclePriceResponse) XXX_Size() int {
	return m.Size()
}
func (m *OraclePriceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OraclePriceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OraclePriceResponse proto.InternalMessageInfo

func (m *OraclePriceResponse) GetPrice() *U128 {
	if m != nil {
		return m.Price
	}
	return nil
}

func (m *OraclePriceResponse) GetErrorCode() ErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return ErrorCode_NONE
}

func (m *OraclePriceResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

type NativeBalanceRequest struct {
	Address []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Ticker  string `protobuf:"bytes,2,opt,name=ticker,proto3" json:"ticker,omitempty"`
}

func (m *NativeBalanceRequest) Reset()         { *m = NativeBalanceRequest{} }
func (m *NativeBalanceRequest) String() string { return proto.CompactTextString(m) }
func (*NativeBalanceRequest) ProtoMessage()    {}
func (*NativeBalanceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f281398717634ce, []int{6}
}
func (m *NativeBalanceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NativeBalanceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NativeBalanceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NativeBalanceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NativeBalanceRequest.Merge(m, src)
}
func (m *NativeBalanceRequest) XXX_Size() int {
	return m.Size()
}
func (m *NativeBalanceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NativeBalanceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NativeBalanceRequest proto.InternalMessageInfo

func (m *NativeBalanceRequest) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *NativeBalanceRequest) GetTicker() string {
	if m != nil {
		return m.Ticker
	}
	return ""
}

type NativeBalanceResponse struct {
	Balance      *U128     `protobuf:"bytes,1,opt,name=balance,proto3" json:"balance,omitempty"`
	ErrorCode    ErrorCode `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3,enum=dfinance.dvm.ErrorCode" json:"error_code,omitempty"`
	ErrorMessage string    `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *NativeBalanceResponse) Reset()         { *m = NativeBalanceResponse{} }
func (m *NativeBalanceResponse) String() string { return proto.CompactTextString(m) }
func (*NativeBalanceResponse) ProtoMessage()    {}
func (*NativeBalanceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f281398717634ce, []int{7}
}
func (m *NativeBalanceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NativeBalanceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NativeBalanceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NativeBalanceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NativeBalanceResponse.Merge(m, src)
}
func (m *NativeBalanceResponse) XXX_Size() int {
	return m.Size()
}
func (m *NativeBalanceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_NativeBalanceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_NativeBalanceResponse proto.InternalMessageInfo

func (m *NativeBalanceResponse) GetBalance() *U128 {
	if m != nil {
		return m.Balance
	}
	return nil
}

func (m *NativeBalanceResponse) GetErrorCode() ErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return ErrorCode_NONE
}

func (m *NativeBalanceResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

type CurrencyInfoRequest struct {
	Ticker string `protobuf:"bytes,2,opt,name=ticker,proto3" json:"ticker,omitempty"`
}

func (m *CurrencyInfoRequest) Reset()         { *m = CurrencyInfoRequest{} }
func (m *CurrencyInfoRequest) String() string { return proto.CompactTextString(m) }
func (*CurrencyInfoRequest) ProtoMessage()    {}
func (*CurrencyInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f281398717634ce, []int{8}
}
func (m *CurrencyInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CurrencyInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CurrencyInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CurrencyInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CurrencyInfoRequest.Merge(m, src)
}
func (m *CurrencyInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *CurrencyInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CurrencyInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CurrencyInfoRequest proto.InternalMessageInfo

func (m *CurrencyInfoRequest) GetTicker() string {
	if m != nil {
		return m.Ticker
	}
	return ""
}

type CurrencyInfo struct {
	Denom       []byte `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	Decimals    uint32 `protobuf:"varint,2,opt,name=decimals,proto3" json:"decimals,omitempty"`
	IsToken     bool   `protobuf:"varint,3,opt,name=is_token,json=isToken,proto3" json:"is_token,omitempty"`
	Address     []byte `protobuf:"bytes,4,opt,name=address,proto3" json:"address,omitempty"`
	TotalSupply *U128  `protobuf:"bytes,5,opt,name=total_supply,json=totalSupply,proto3" json:"total_supply,omitempty"`
}

func (m *CurrencyInfo) Reset()         { *m = CurrencyInfo{} }
func (m *CurrencyInfo) String() string { return proto.CompactTextString(m) }
func (*CurrencyInfo) ProtoMessage()    {}
func (*CurrencyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f281398717634ce, []int{9}
}
func (m *CurrencyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CurrencyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CurrencyInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CurrencyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CurrencyInfo.Merge(m, src)
}
func (m *CurrencyInfo) XXX_Size() int {
	return m.Size()
}
func (m *CurrencyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CurrencyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CurrencyInfo proto.InternalMessageInfo

func (m *CurrencyInfo) GetDenom() []byte {
	if m != nil {
		return m.Denom
	}
	return nil
}

func (m *CurrencyInfo) GetDecimals() uint32 {
	if m != nil {
		return m.Decimals
	}
	return 0
}

func (m *CurrencyInfo) GetIsToken() bool {
	if m != nil {
		return m.IsToken
	}
	return false
}

func (m *CurrencyInfo) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *CurrencyInfo) GetTotalSupply() *U128 {
	if m != nil {
		return m.TotalSupply
	}
	return nil
}

type CurrencyInfoResponse struct {
	Info         *CurrencyInfo `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
	ErrorCode    ErrorCode     `protobuf:"varint,2,opt,name=error_code,json=errorCode,proto3,enum=dfinance.dvm.ErrorCode" json:"error_code,omitempty"`
	ErrorMessage string        `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *CurrencyInfoResponse) Reset()         { *m = CurrencyInfoResponse{} }
func (m *CurrencyInfoResponse) String() string { return proto.CompactTextString(m) }
func (*CurrencyInfoResponse) ProtoMessage()    {}
func (*CurrencyInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1f281398717634ce, []int{10}
}
func (m *CurrencyInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CurrencyInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CurrencyInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CurrencyInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CurrencyInfoResponse.Merge(m, src)
}
func (m *CurrencyInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *CurrencyInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CurrencyInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CurrencyInfoResponse proto.InternalMessageInfo

func (m *CurrencyInfoResponse) GetInfo() *CurrencyInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *CurrencyInfoResponse) GetErrorCode() ErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return ErrorCode_NONE
}

func (m *CurrencyInfoResponse) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func init() {
	proto.RegisterEnum("dfinance.dvm.ErrorCode", ErrorCode_name, ErrorCode_value)
	proto.RegisterType((*DSAccessPath)(nil), "dfinance.dvm.DSAccessPath")
	proto.RegisterType((*DSRawResponse)(nil), "dfinance.dvm.DSRawResponse")
	proto.RegisterType((*DSAccessPaths)(nil), "dfinance.dvm.DSAccessPaths")
	proto.RegisterType((*DSRawResponses)(nil), "dfinance.dvm.DSRawResponses")
	proto.RegisterType((*OraclePriceRequest)(nil), "dfinance.dvm.OraclePriceRequest")
	proto.RegisterType((*OraclePriceResponse)(nil), "dfinance.dvm.OraclePriceResponse")
	proto.RegisterType((*NativeBalanceRequest)(nil), "dfinance.dvm.NativeBalanceRequest")
	proto.RegisterType((*NativeBalanceResponse)(nil), "dfinance.dvm.NativeBalanceResponse")
	proto.RegisterType((*CurrencyInfoRequest)(nil), "dfinance.dvm.CurrencyInfoRequest")
	proto.RegisterType((*CurrencyInfo)(nil), "dfinance.dvm.CurrencyInfo")
	proto.RegisterType((*CurrencyInfoResponse)(nil), "dfinance.dvm.CurrencyInfoResponse")
}

func init() { proto.RegisterFile("dfinance/dvm/data-source.proto", fileDescriptor_1f281398717634ce) }

var fileDescriptor_1f281398717634ce = []byte{
	// 724 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0xc1, 0x4e, 0xdb, 0x4c,
	0x10, 0x8e, 0x21, 0x21, 0xc9, 0x24, 0x40, 0xb4, 0xf0, 0xff, 0x4d, 0x43, 0x9b, 0x82, 0x91, 0xaa,
	0x08, 0x95, 0xa4, 0x04, 0xb5, 0xea, 0xa1, 0x97, 0x40, 0xa2, 0xb4, 0x95, 0x08, 0x74, 0x43, 0x55,
	0x09, 0xa9, 0x8a, 0x36, 0xf6, 0x02, 0x16, 0xb1, 0xd7, 0xf5, 0xae, 0x83, 0xb8, 0xf5, 0x11, 0xfa,
	0x00, 0x3d, 0xb5, 0xd7, 0x1e, 0xfa, 0x18, 0x3d, 0x72, 0xec, 0xb1, 0x82, 0x17, 0xa9, 0xbc, 0xb6,
	0x83, 0x4d, 0x1b, 0xdf, 0xb8, 0xed, 0xcc, 0x7c, 0xf3, 0x79, 0xbe, 0xd9, 0x1d, 0x0f, 0x54, 0xf5,
	0x63, 0xc3, 0x22, 0x96, 0x46, 0x1b, 0xfa, 0xd8, 0x6c, 0xe8, 0x44, 0x90, 0x4d, 0xce, 0x5c, 0x47,
	0xa3, 0x75, 0xdb, 0x61, 0x82, 0xa1, 0x62, 0x18, 0xaf, 0xeb, 0x63, 0xb3, 0xf2, 0x28, 0x86, 0xd6,
	0x98, 0x69, 0x32, 0x6b, 0x53, 0x5c, 0xd8, 0x94, 0xfb, 0x70, 0xf5, 0x25, 0x14, 0xdb, 0xfd, 0x96,
	0xa6, 0x51, 0xce, 0x0f, 0x88, 0x38, 0x45, 0x65, 0xc8, 0x12, 0x5d, 0x77, 0x28, 0xe7, 0x65, 0x65,
	0x55, 0xa9, 0x15, 0x71, 0x68, 0x22, 0x04, 0x69, 0x9b, 0x88, 0xd3, 0xf2, 0x8c, 0x74, 0xcb, 0xb3,
	0xfa, 0x49, 0x81, 0xf9, 0x76, 0x1f, 0x93, 0x73, 0x4c, 0xb9, 0xcd, 0x2c, 0x4e, 0x3d, 0xd4, 0x70,
	0xc4, 0x86, 0x41, 0xb2, 0x3c, 0xa3, 0xe7, 0x00, 0xd4, 0x71, 0x98, 0x33, 0xd0, 0x98, 0x4e, 0x65,
	0xfe, 0x42, 0xf3, 0x5e, 0x3d, 0x5a, 0x67, 0xbd, 0xe3, 0xc5, 0x77, 0x99, 0x4e, 0x71, 0x9e, 0x86,
	0x47, 0xb4, 0x0e, 0xf3, 0x7e, 0x9e, 0x49, 0x39, 0x27, 0x27, 0xb4, 0x3c, 0xbb, 0xaa, 0xd4, 0xf2,
	0xb8, 0x28, 0x9d, 0x7b, 0xbe, 0x4f, 0x6d, 0x79, 0x15, 0xdc, 0x08, 0xe0, 0xe8, 0x29, 0x64, 0xbc,
	0xda, 0xbc, 0xfa, 0x67, 0x6b, 0x85, 0x66, 0x25, 0xfe, 0xa1, 0x28, 0x16, 0xfb, 0x40, 0xf5, 0x31,
	0x2c, 0xc4, 0x44, 0x70, 0xb4, 0x0c, 0x19, 0xaf, 0x72, 0x9f, 0xa3, 0x88, 0x7d, 0x43, 0xc5, 0x80,
	0xf6, 0x1d, 0xa2, 0x8d, 0xe8, 0x81, 0x63, 0x68, 0x14, 0xd3, 0x8f, 0x2e, 0xe5, 0x02, 0x3d, 0x04,
	0xd0, 0x5c, 0xc7, 0xa1, 0x96, 0x76, 0x31, 0xd8, 0x92, 0xba, 0xf3, 0x38, 0x1f, 0x7a, 0xb6, 0x62,
	0xe1, 0xa6, 0x14, 0x1f, 0x09, 0x37, 0xd5, 0x2f, 0x0a, 0x2c, 0xc5, 0x48, 0x83, 0x3e, 0xd6, 0x20,
	0x63, 0x7b, 0x0e, 0x49, 0x58, 0x68, 0xa2, 0xb8, 0x0a, 0x77, 0xab, 0xf9, 0x02, 0xfb, 0x80, 0xbb,
	0xed, 0xee, 0x2b, 0x58, 0xee, 0x11, 0x61, 0x8c, 0xe9, 0x0e, 0x19, 0x79, 0x74, 0xa1, 0xe8, 0xe9,
	0xcf, 0xe4, 0x7f, 0x98, 0x13, 0x86, 0x76, 0x46, 0x9d, 0x40, 0x6b, 0x60, 0xa9, 0x5f, 0x15, 0xf8,
	0xef, 0x16, 0x55, 0x20, 0xf5, 0x09, 0x64, 0x87, 0xbe, 0x2b, 0x41, 0x6c, 0x08, 0xb9, 0x5b, 0xb9,
	0x9b, 0xb0, 0xb4, 0x1b, 0x5c, 0xcd, 0x6b, 0xeb, 0x98, 0x85, 0x6a, 0xa7, 0x69, 0xfa, 0xae, 0x40,
	0x31, 0x8a, 0xf7, 0xde, 0x8d, 0x4e, 0x2d, 0x66, 0x06, 0x4d, 0xf1, 0x0d, 0x54, 0x81, 0x9c, 0x4e,
	0x35, 0xc3, 0x24, 0x23, 0x2e, 0x09, 0xe6, 0xf1, 0xc4, 0x46, 0xf7, 0x21, 0x67, 0xf0, 0x81, 0x60,
	0x67, 0xd4, 0x92, 0x15, 0xe5, 0x70, 0xd6, 0xe0, 0x87, 0x9e, 0x19, 0xed, 0x71, 0x3a, 0xde, 0xe3,
	0x67, 0x50, 0x14, 0x4c, 0x90, 0xd1, 0x80, 0xbb, 0xb6, 0x3d, 0xba, 0x28, 0x67, 0xa6, 0xb6, 0xad,
	0x20, 0x71, 0x7d, 0x09, 0x53, 0xbf, 0x29, 0xb0, 0x1c, 0x97, 0x17, 0xdc, 0x40, 0x1d, 0xd2, 0x86,
	0x75, 0xcc, 0x82, 0xf6, 0xdf, 0x9a, 0x98, 0x58, 0x86, 0xc4, 0xdd, 0xe9, 0x1d, 0x6c, 0x6c, 0x43,
	0x7e, 0x92, 0x8c, 0x72, 0x90, 0xee, 0xed, 0xf7, 0x3a, 0xa5, 0x14, 0x5a, 0x84, 0xc2, 0x4e, 0xab,
	0x3d, 0xc0, 0x9d, 0xb7, 0xef, 0x3a, 0xfd, 0xc3, 0x92, 0x82, 0x0a, 0x90, 0xed, 0xed, 0x0f, 0xda,
	0xad, 0xc3, 0x56, 0x69, 0xa6, 0xf9, 0x63, 0x16, 0xf2, 0xed, 0x7e, 0x9f, 0x3a, 0x63, 0x6f, 0x24,
	0x76, 0x61, 0xae, 0x4b, 0x05, 0x26, 0xe7, 0x28, 0x61, 0xfa, 0x2b, 0x2b, 0xb7, 0x63, 0x91, 0x5f,
	0x80, 0x9a, 0x42, 0x6f, 0xa0, 0xb0, 0xe7, 0x8e, 0x84, 0x11, 0x30, 0xad, 0x4c, 0x67, 0xe2, 0x95,
	0x07, 0x09, 0x54, 0x5c, 0x4d, 0xa1, 0xf7, 0xb0, 0xd0, 0xa5, 0x22, 0x32, 0xe7, 0x68, 0x35, 0x9e,
	0xf1, 0xf7, 0x7f, 0xa5, 0xb2, 0x96, 0x80, 0x98, 0x14, 0xf9, 0x01, 0x4a, 0x5d, 0x2a, 0x62, 0x73,
	0x85, 0xd4, 0x78, 0xe2, 0xbf, 0xe6, 0xb7, 0xb2, 0x9e, 0x88, 0x99, 0xd0, 0x1f, 0xc1, 0x62, 0x97,
	0x8a, 0xd8, 0x13, 0x5f, 0x4b, 0x78, 0x1d, 0x01, 0xb9, 0x9a, 0x04, 0x09, 0xb9, 0x77, 0xda, 0x3f,
	0xaf, 0xaa, 0xca, 0xe5, 0x55, 0x55, 0xf9, 0x7d, 0x55, 0x55, 0x3e, 0x5f, 0x57, 0x53, 0x97, 0xd7,
	0xd5, 0xd4, 0xaf, 0xeb, 0x6a, 0xea, 0x68, 0xe3, 0xc4, 0x10, 0xa7, 0xee, 0xb0, 0xae, 0x31, 0xb3,
	0x71, 0xb3, 0xbf, 0xb8, 0x20, 0xc2, 0x60, 0x56, 0xc3, 0x3e, 0x3b, 0x69, 0xc8, 0x0d, 0xe6, 0xad,
	0xb4, 0xe1, 0x9c, 0x5c, 0x63, 0xdb, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x7c, 0x5c, 0x17, 0x67,
	0x17, 0x07, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DSServiceClient is the client API for DSService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DSServiceClient interface {
	GetRaw(ctx context.Context, in *DSAccessPath, opts ...grpc.CallOption) (*DSRawResponse, error)
	MultiGetRaw(ctx context.Context, in *DSAccessPaths, opts ...grpc.CallOption) (*DSRawResponses, error)
	GetOraclePrice(ctx context.Context, in *OraclePriceRequest, opts ...grpc.CallOption) (*OraclePriceResponse, error)
	GetNativeBalance(ctx context.Context, in *NativeBalanceRequest, opts ...grpc.CallOption) (*NativeBalanceResponse, error)
	GetCurrencyInfo(ctx context.Context, in *CurrencyInfoRequest, opts ...grpc.CallOption) (*CurrencyInfoResponse, error)
}

type dSServiceClient struct {
	cc grpc1.ClientConn
}

func NewDSServiceClient(cc grpc1.ClientConn) DSServiceClient {
	return &dSServiceClient{cc}
}

func (c *dSServiceClient) GetRaw(ctx context.Context, in *DSAccessPath, opts ...grpc.CallOption) (*DSRawResponse, error) {
	out := new(DSRawResponse)
	err := c.cc.Invoke(ctx, "/dfinance.dvm.DSService/GetRaw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dSServiceClient) MultiGetRaw(ctx context.Context, in *DSAccessPaths, opts ...grpc.CallOption) (*DSRawResponses, error) {
	out := new(DSRawResponses)
	err := c.cc.Invoke(ctx, "/dfinance.dvm.DSService/MultiGetRaw", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dSServiceClient) GetOraclePrice(ctx context.Context, in *OraclePriceRequest, opts ...grpc.CallOption) (*OraclePriceResponse, error) {
	out := new(OraclePriceResponse)
	err := c.cc.Invoke(ctx, "/dfinance.dvm.DSService/GetOraclePrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dSServiceClient) GetNativeBalance(ctx context.Context, in *NativeBalanceRequest, opts ...grpc.CallOption) (*NativeBalanceResponse, error) {
	out := new(NativeBalanceResponse)
	err := c.cc.Invoke(ctx, "/dfinance.dvm.DSService/GetNativeBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dSServiceClient) GetCurrencyInfo(ctx context.Context, in *CurrencyInfoRequest, opts ...grpc.CallOption) (*CurrencyInfoResponse, error) {
	out := new(CurrencyInfoResponse)
	err := c.cc.Invoke(ctx, "/dfinance.dvm.DSService/GetCurrencyInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DSServiceServer is the server API for DSService service.
type DSServiceServer interface {
	GetRaw(context.Context, *DSAccessPath) (*DSRawResponse, error)
	MultiGetRaw(context.Context, *DSAccessPaths) (*DSRawResponses, error)
	GetOraclePrice(context.Context, *OraclePriceRequest) (*OraclePriceResponse, error)
	GetNativeBalance(context.Context, *NativeBalanceRequest) (*NativeBalanceResponse, error)
	GetCurrencyInfo(context.Context, *CurrencyInfoRequest) (*CurrencyInfoResponse, error)
}

// UnimplementedDSServiceServer can be embedded to have forward compatible implementations.
type UnimplementedDSServiceServer struct {
}

func (*UnimplementedDSServiceServer) GetRaw(ctx context.Context, req *DSAccessPath) (*DSRawResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRaw not implemented")
}
func (*UnimplementedDSServiceServer) MultiGetRaw(ctx context.Context, req *DSAccessPaths) (*DSRawResponses, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MultiGetRaw not implemented")
}
func (*UnimplementedDSServiceServer) GetOraclePrice(ctx context.Context, req *OraclePriceRequest) (*OraclePriceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOraclePrice not implemented")
}
func (*UnimplementedDSServiceServer) GetNativeBalance(ctx context.Context, req *NativeBalanceRequest) (*NativeBalanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNativeBalance not implemented")
}
func (*UnimplementedDSServiceServer) GetCurrencyInfo(ctx context.Context, req *CurrencyInfoRequest) (*CurrencyInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCurrencyInfo not implemented")
}

func RegisterDSServiceServer(s grpc1.Server, srv DSServiceServer) {
	s.RegisterService(&_DSService_serviceDesc, srv)
}

func _DSService_GetRaw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DSAccessPath)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DSServiceServer).GetRaw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dfinance.dvm.DSService/GetRaw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DSServiceServer).GetRaw(ctx, req.(*DSAccessPath))
	}
	return interceptor(ctx, in, info, handler)
}

func _DSService_MultiGetRaw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DSAccessPaths)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DSServiceServer).MultiGetRaw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dfinance.dvm.DSService/MultiGetRaw",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DSServiceServer).MultiGetRaw(ctx, req.(*DSAccessPaths))
	}
	return interceptor(ctx, in, info, handler)
}

func _DSService_GetOraclePrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OraclePriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DSServiceServer).GetOraclePrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dfinance.dvm.DSService/GetOraclePrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DSServiceServer).GetOraclePrice(ctx, req.(*OraclePriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DSService_GetNativeBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NativeBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DSServiceServer).GetNativeBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dfinance.dvm.DSService/GetNativeBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DSServiceServer).GetNativeBalance(ctx, req.(*NativeBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DSService_GetCurrencyInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CurrencyInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DSServiceServer).GetCurrencyInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dfinance.dvm.DSService/GetCurrencyInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DSServiceServer).GetCurrencyInfo(ctx, req.(*CurrencyInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DSService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dfinance.dvm.DSService",
	HandlerType: (*DSServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetRaw",
			Handler:    _DSService_GetRaw_Handler,
		},
		{
			MethodName: "MultiGetRaw",
			Handler:    _DSService_MultiGetRaw_Handler,
		},
		{
			MethodName: "GetOraclePrice",
			Handler:    _DSService_GetOraclePrice_Handler,
		},
		{
			MethodName: "GetNativeBalance",
			Handler:    _DSService_GetNativeBalance_Handler,
		},
		{
			MethodName: "GetCurrencyInfo",
			Handler:    _DSService_GetCurrencyInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dfinance/dvm/data-source.proto",
}

func (m *DSAccessPath) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DSAccessPath) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DSAccessPath) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintDataSource(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintDataSource(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DSRawResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DSRawResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DSRawResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintDataSource(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ErrorCode != 0 {
		i = encodeVarintDataSource(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Blob) > 0 {
		i -= len(m.Blob)
		copy(dAtA[i:], m.Blob)
		i = encodeVarintDataSource(dAtA, i, uint64(len(m.Blob)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DSAccessPaths) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DSAccessPaths) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DSAccessPaths) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Paths) > 0 {
		for iNdEx := len(m.Paths) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Paths[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDataSource(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DSRawResponses) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DSRawResponses) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DSRawResponses) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Blobs) > 0 {
		for iNdEx := len(m.Blobs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Blobs[iNdEx])
			copy(dAtA[i:], m.Blobs[iNdEx])
			i = encodeVarintDataSource(dAtA, i, uint64(len(m.Blobs[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OraclePriceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OraclePriceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OraclePriceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Currency_2) > 0 {
		i -= len(m.Currency_2)
		copy(dAtA[i:], m.Currency_2)
		i = encodeVarintDataSource(dAtA, i, uint64(len(m.Currency_2)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Currency_1) > 0 {
		i -= len(m.Currency_1)
		copy(dAtA[i:], m.Currency_1)
		i = encodeVarintDataSource(dAtA, i, uint64(len(m.Currency_1)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OraclePriceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OraclePriceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OraclePriceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintDataSource(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ErrorCode != 0 {
		i = encodeVarintDataSource(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Price != nil {
		{
			size, err := m.Price.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDataSource(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NativeBalanceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NativeBalanceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NativeBalanceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintDataSource(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintDataSource(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NativeBalanceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NativeBalanceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NativeBalanceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintDataSource(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ErrorCode != 0 {
		i = encodeVarintDataSource(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Balance != nil {
		{
			size, err := m.Balance.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDataSource(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CurrencyInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CurrencyInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CurrencyInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintDataSource(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *CurrencyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CurrencyInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CurrencyInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalSupply != nil {
		{
			size, err := m.TotalSupply.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDataSource(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintDataSource(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x22
	}
	if m.IsToken {
		i--
		if m.IsToken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Decimals != 0 {
		i = encodeVarintDataSource(dAtA, i, uint64(m.Decimals))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintDataSource(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CurrencyInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CurrencyInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CurrencyInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintDataSource(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ErrorCode != 0 {
		i = encodeVarintDataSource(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x10
	}
	if m.Info != nil {
		{
			size, err := m.Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDataSource(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintDataSource(dAtA []byte, offset int, v uint64) int {
	offset -= sovDataSource(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DSAccessPath) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovDataSource(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovDataSource(uint64(l))
	}
	return n
}

func (m *DSRawResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Blob)
	if l > 0 {
		n += 1 + l + sovDataSource(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovDataSource(uint64(m.ErrorCode))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovDataSource(uint64(l))
	}
	return n
}

func (m *DSAccessPaths) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Paths) > 0 {
		for _, e := range m.Paths {
			l = e.Size()
			n += 1 + l + sovDataSource(uint64(l))
		}
	}
	return n
}

func (m *DSRawResponses) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Blobs) > 0 {
		for _, b := range m.Blobs {
			l = len(b)
			n += 1 + l + sovDataSource(uint64(l))
		}
	}
	return n
}

func (m *OraclePriceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Currency_1)
	if l > 0 {
		n += 1 + l + sovDataSource(uint64(l))
	}
	l = len(m.Currency_2)
	if l > 0 {
		n += 1 + l + sovDataSource(uint64(l))
	}
	return n
}

func (m *OraclePriceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Price != nil {
		l = m.Price.Size()
		n += 1 + l + sovDataSource(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovDataSource(uint64(m.ErrorCode))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovDataSource(uint64(l))
	}
	return n
}

func (m *NativeBalanceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovDataSource(uint64(l))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovDataSource(uint64(l))
	}
	return n
}

func (m *NativeBalanceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Balance != nil {
		l = m.Balance.Size()
		n += 1 + l + sovDataSource(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovDataSource(uint64(m.ErrorCode))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovDataSource(uint64(l))
	}
	return n
}

func (m *CurrencyInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovDataSource(uint64(l))
	}
	return n
}

func (m *CurrencyInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovDataSource(uint64(l))
	}
	if m.Decimals != 0 {
		n += 1 + sovDataSource(uint64(m.Decimals))
	}
	if m.IsToken {
		n += 2
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovDataSource(uint64(l))
	}
	if m.TotalSupply != nil {
		l = m.TotalSupply.Size()
		n += 1 + l + sovDataSource(uint64(l))
	}
	return n
}

func (m *CurrencyInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovDataSource(uint64(l))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovDataSource(uint64(m.ErrorCode))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovDataSource(uint64(l))
	}
	return n
}

func sovDataSource(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDataSource(x uint64) (n int) {
	return sovDataSource(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DSAccessPath) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataSource
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DSAccessPath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DSAccessPath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDataSource
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDataSource
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = append(m.Path[:0], dAtA[iNdEx:postIndex]...)
			if m.Path == nil {
				m.Path = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataSource(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataSource
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DSRawResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataSource
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DSRawResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DSRawResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blob", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDataSource
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blob = append(m.Blob[:0], dAtA[iNdEx:postIndex]...)
			if m.Blob == nil {
				m.Blob = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataSource
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataSource(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataSource
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DSAccessPaths) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataSource
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DSAccessPaths: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DSAccessPaths: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataSource
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paths = append(m.Paths, &DSAccessPath{})
			if err := m.Paths[len(m.Paths)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataSource(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataSource
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DSRawResponses) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataSource
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DSRawResponses: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DSRawResponses: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blobs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDataSource
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blobs = append(m.Blobs, make([]byte, postIndex-iNdEx))
			copy(m.Blobs[len(m.Blobs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataSource(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataSource
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OraclePriceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataSource
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OraclePriceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OraclePriceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency_1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataSource
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency_1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency_2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataSource
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency_2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataSource(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataSource
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OraclePriceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataSource
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OraclePriceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OraclePriceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataSource
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Price == nil {
				m.Price = &U128{}
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataSource
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataSource(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataSource
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NativeBalanceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataSource
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NativeBalanceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NativeBalanceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDataSource
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataSource
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataSource(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataSource
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NativeBalanceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataSource
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NativeBalanceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NativeBalanceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataSource
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Balance == nil {
				m.Balance = &U128{}
			}
			if err := m.Balance.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataSource
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataSource(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataSource
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CurrencyInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataSource
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CurrencyInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CurrencyInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataSource
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataSource(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataSource
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CurrencyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataSource
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CurrencyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CurrencyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDataSource
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = append(m.Denom[:0], dAtA[iNdEx:postIndex]...)
			if m.Denom == nil {
				m.Denom = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
			}
			m.Decimals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decimals |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsToken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsToken = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDataSource
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSupply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataSource
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TotalSupply == nil {
				m.TotalSupply = &U128{}
			}
			if err := m.TotalSupply.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataSource(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataSource
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CurrencyInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDataSource
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CurrencyInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CurrencyInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDataSource
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &CurrencyInfo{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= ErrorCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDataSource
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDataSource
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDataSource(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDataSource
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDataSource(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDataSource
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDataSource
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDataSource
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDataSource
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDataSource
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDataSource        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDataSource          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDataSource = fmt.Errorf("proto: unexpected end of group")
)
